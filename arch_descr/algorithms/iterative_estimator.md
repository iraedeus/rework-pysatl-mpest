# IterativeEstimator(BaseEstimator)

Конкретный класс, реализующий итеративные алгоритмы оценки параметров смеси распределений.



### Атрибуты

#### - breakpointers: list[BaseBreakpointer]

Условия остановки алгоритма. Не знаю, нужно ли делать разделение на:

1. Остановка если хотя бы один из брейкпоинтеров сработал
2. Остановка только если все из брейкпоинтеров сработали

Во втором случае интуитивно кажется, что алгоритм может оказаться бесконечным (но это не точно)



#### - pruners: list[BasePruners]

Классы удаляющие компоненты из смеси по некоему условию. Актуален тот же вопрос что и для брейкпоинтеров.



#### - steps: list[EstimatorStep]

Список последовательности шагов, на каждой итерации алгоритм будет по ним проходить начиная с 0 шага и заканчивая последним.



#### + context: Context | dict

Общие данные алгоритма, к которым имеют доступ шаги. Т.к. они выполняются последовательно никакой конкурентности на запись и чтение нет.

Не знаю что лучше: сделать дикт или отдельный датакласс:

1. В случае с диктом, необходимо четко писать ключи без ошибок и т.д., может быть неудобным дебажить
2. В случае с контекстом, боюсь он может очень сильно разрастись, т.к. различные ветви дерева доступных шагов могут использовать различные конфигурации полей, и все их сувать в контекст как то странно...



### Методы

#### - validate()

Функция для валидации конфигурации алгоритма. Проверяет:

- Что все шаги могут друг за другом идти.
- Применимость каждого шага к компонентам.



#### + fit(X, mixture): mixture

Выполняет каждый элемент из `steps` последовательно. В конце каждой итерации идет проверка на выполнение условия остановки и, если остановка не нужна, проверка на удаление компоненты.



## Мысли

Для поддержки своего пайплайна для каждой компоненты можно добавить что то вроде `global_steps` которые отрабатывают для каждой компоненты и `local_steps` содержащий пайплайны для каждой компоненты (а что если идет сначала шаг из `global_step`, а потом шаг из `local_steps` а потом снова из `global_steps`?)

Если так делать кстати, то получится распараллелить каждую итерацию (очень предпочтительно!)